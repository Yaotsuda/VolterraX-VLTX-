// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "./VolterraX (VLTX).sol";

contract VLTXStaking is Ownable, Pausable {
    VLTXToken public token;

    struct Package {
        uint256 lockPeriod;
        uint256 rewardRate;
    }

    struct StakeInfo {
        uint256 amount;
        uint256 startTime;
        uint256 packageId;
        uint256 claimedReward;
        uint256 lastClaimTime;
        bool active;
    }

    mapping(address => StakeInfo) public stakes;
    Package[] public packages;

    event Staked(address indexed user, uint256 amount, uint256 packageId);
    event RewardsClaimed(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount, uint256 remainingReward);

    constructor(address _token, address initialOwner) Ownable(initialOwner) {
        token = VLTXToken(_token);
        packages.push(Package(0, 1));
        packages.push(Package(30 days, 2));
        packages.push(Package(90 days, 8));
        packages.push(Package(180 days, 20));
        packages.push(Package(365 days, 50));
    }

    function stake(uint256 amount, uint256 packageId) external whenNotPaused {
        require(amount > 0, "Amount must be > 0");
        require(packageId < packages.length, "Invalid package");
        require(!stakes[msg.sender].active, "Already staking");

        token.transferFrom(msg.sender, address(this), amount);

        stakes[msg.sender] = StakeInfo({
            amount: amount,
            startTime: block.timestamp,
            packageId: packageId,
            claimedReward: 0,
            lastClaimTime: 0,
            active: true
        });

        emit Staked(msg.sender, amount, packageId);
    }

    function claimRewards() external whenNotPaused {
        StakeInfo storage s = stakes[msg.sender];
        require(s.active, "No active stake");
        require(block.timestamp >= s.lastClaimTime + 1 days, "Claim allowed once per day");

        Package memory p = packages[s.packageId];
        uint256 elapsed = block.timestamp - s.startTime;
        uint256 claimable;
        uint256 totalReward;

        if (p.lockPeriod == 0) {
            totalReward = (s.amount * p.rewardRate * elapsed) / (30 days * 100);
            claimable = totalReward;
        } else {
            if (elapsed > p.lockPeriod) {
                elapsed = p.lockPeriod;
            }
            totalReward = (s.amount * p.rewardRate) / 100;
            claimable = (totalReward * elapsed) / p.lockPeriod;
        }

        uint256 toClaim = claimable - s.claimedReward;
        require(toClaim > 0, "No rewards available");

        s.claimedReward += toClaim;
        s.lastClaimTime = block.timestamp;

        token.mint(msg.sender, toClaim);

        emit RewardsClaimed(msg.sender, toClaim);
    }

    function unstake() external whenNotPaused {
        StakeInfo storage s = stakes[msg.sender];
        require(s.active, "No active stake");

        Package memory p = packages[s.packageId];
        uint256 totalReward;
        uint256 remainingReward;

        if (p.lockPeriod == 0) {
            totalReward = (s.amount * p.rewardRate * (block.timestamp - s.startTime)) / (30 days * 100);
            remainingReward = totalReward - s.claimedReward;
        } else {
            require(block.timestamp >= s.startTime + p.lockPeriod, "Lock period not finished");
            totalReward = (s.amount * p.rewardRate) / 100;
            remainingReward = totalReward - s.claimedReward;
        }

        token.transfer(msg.sender, s.amount);

        if (remainingReward > 0) {
            token.mint(msg.sender, remainingReward);
        }

        s.active = false;

        emit Unstaked(msg.sender, s.amount, remainingReward);
    }

    function addPackage(uint256 lockPeriod, uint256 rewardRate) external onlyOwner {
        packages.push(Package(lockPeriod, rewardRate));
    }

    function updatePackage(uint256 packageId, uint256 lockPeriod, uint256 rewardRate) external onlyOwner {
        require(packageId < packages.length, "Invalid package");
        packages[packageId] = Package(lockPeriod, rewardRate);
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}
